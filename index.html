<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section id="intro">
					<h3>Express yourself through Haskell Type-classes</h3>
					<div>John Ky @newhoggy</div>
					<div>Arbor Networks</div>
					<div><a href="https://haskell-works.github.io/talk-typeclasses/">https://haskell-works.github.io/talk-typeclasses/</a></div>
				</section>
				<section>
					<section>
						<h3>Introduction</h3>
					</section>
					<section>
						<h4>Code is Hard!</h4>
						<ul>
							<li class="fragment fade-in">
									Complicated
							</li>
							<li class="fragment fade-in">
									Full of leaky abstractions
							</li>
							<li class="fragment fade-in">
									Not reusable
							</li>
							<li class="fragment fade-in">
									Repetitive
							</li>
							<li class="fragment fade-in">
									Imprecise
							</li>
							<li class="fragment fade-in">
									Not extensible
							</li>
						</ul>
					</section>
				</section>
				<section id="parametricity">
					<section id="parametricity-1">
						<h3>Parametricity</h3>
					</section>
					<section id="parametricity-2">
						How many possible implementations of this function?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo = True ; foo = False
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|Bool| = 2
								\end{equation}
							</script>
						</span>
						<span class="fragment fade-in">
							We say that <code data-trim data-noescape class=language-haskell>Bool</code>
							has 2 inhabitants.
						</span>
					</section>
					<section id="parametricity-3">
						<pre><code data-trim data-noescape class=language-haskell>
							data TriState = On | Off | Unknown
						</code></pre>
						How many inhabitants?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: TriState
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo = On
								foo = Off
								foo = Unknown
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|TriState| = 3
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-4">
						How many inhabitants?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Bool -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo True = True  ; foo False = True
								foo True = False ; foo False = True
								foo True = True  ; foo False = False
								foo True = False ; foo False = False
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|Bool \rightarrow Bool| = |Bool| ^ {|Bool|} = 2 ^ 2 = 4
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-5">
						<pre><code data-trim data-noescape class=language-haskell>
							data TriState = On | Off | Unknown
						</code></pre>
						How many inhabitants?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: TriState -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo On = True  ; foo Off = True  ; foo Unkown = True
								foo On = False ; foo Off = True  ; foo Unkown = True
								foo On = True  ; foo Off = False ; foo Unkown = True
								foo On = False ; foo Off = False ; foo Unkown = True
								foo On = True  ; foo Off = True  ; foo Unkown = False
								foo On = False ; foo Off = True  ; foo Unkown = False
								foo On = True  ; foo Off = False ; foo Unkown = False
								foo On = False ; foo Off = False ; foo Unkown = False
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|TriState \rightarrow Bool| = |Bool| ^ {|TriState|} = 2 ^ 3 = 8
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-6">
						How many inhabitants?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: A -> B
						</code></pre>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|A \rightarrow B| = |B| ^ {|A|}
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-7">
						How many inhabitants?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Int -> Int 		-- Int is a 64-bit integer
						</code></pre>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									\begin{split}
										|Int \rightarrow Int| & = (2 ^ {64}) ^ {2 ^ {64}} \\
																					& = 18446744073709551616 ^ {18446744073709551616} \\
																					& > 10 ^ {82} \\
																					& ≈ estimated
																							\hspace{1mm} number
																							\hspace{1mm} of
																							\hspace{1mm} atoms
																							\hspace{1mm} in
																							\hspace{1mm} the
																							\hspace{1mm} universe
									\end{split}
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-7">
						Well, that escalated quickly.
						<img src="assets/escalated.png"/>
					</section>
					<section id="parametricity-7">
						It doesn't get better
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Int -> String
						</code></pre>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									\begin{split}
										|Int \rightarrow String| 	& = |String| ^ {|Int|} \\
																							& = \infty ^ {18446744073709551616}
									\end{split}
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-6">
						Are there functions where the number of inhabitants
						don't escalate so much?
					</section>
					<section id="parametricity-6">
						How about this one?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo x = x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|a \rightarrow a| = 1
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-6">
						Or this one?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: b -> a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo _ x = x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|b \rightarrow a \rightarrow a| = 1
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-6">
						Or this one?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: (a -> b) -> a -> b
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo f x = f x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|(a \rightarrow b) \rightarrow a \rightarrow b| = 1
								\end{equation}
							</script>
						</span>
					</section>
					<section>
						But?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: (a -> b) -> a -> b
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo :: (a -> b) -> (a -> b)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo = id
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo = \f -> f
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo f = f
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo f = \x -> f x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								foo f x = f x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									|(a \rightarrow b) \rightarrow a \rightarrow b| = 1
								\end{equation}
							</script>
						</span>
					</section>
					<section id="parametricity-6">
						<div style="font-style: italic; color: cyan">
							"The purpose of abstraction is not to be vague,
						</div>
						<div class="fragment fade-in" style="font-style: italic; color: cyan">
							but to create a new semantic level in which one can be absolutely precise"
						</div>
						<div class="fragment fade-in" style="font-size: 80%">
								"The Humble Programmer" by Edsger W. Dijkstra,<br>
								Turing Award lecture 1972
						</div>
					</section>
				</section>
				<section id="algebraic-data-types">
					<section>
						<h3>Algebraic Data Types</h3>
					</section>
					<section id="boolean-1">
						Boolean type
						<pre><code data-trim data-noescape class=language-haskell>
							data Bool = True | False
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :t False
								False :: Bool
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :t True
								True :: Bool
							</code></pre>
						</span>
					</section>
					<section id="boolean-2">
						Boolean type
						<pre><code data-trim data-noescape class=language-haskell>
							data Bool = True | False
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
λ> True
<interactive>:11:1: error:
    • No instance for (Show Bool) arising from a use of ‘print’
      There are instances for similar types:
        instance Show Prelude.Bool -- Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
(0.00 secs,)
							</code></pre>
						</span>
					</section>
					<section id="boolean-3">
						Boolean type
						<pre><code data-trim data-noescape class=language-haskell>
							data Bool = True | False<span class="fragment fade-in"> deriving Show</span>
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> True
								True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> show True
								"True"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :t show
								show :: Show a => a -> String
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :info Show
								class Show a where
								  show :: a -> String
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="typeclass-show">
						<h3>Show Typeclass</h3>
					</section>
					<section id="typeclasses-show-1">
						Show Typeclass
						<pre><code data-trim data-noescape class=language-haskell>
							class Show a where
							  show :: a -> String
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Show Color where
								  show Red   = "Red"
								  show Green = "Green"
								  show Blue  = "Blue"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								deriving instance Show Color
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue deriving Show
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-show-1">
						Show Typeclass implementation
						<pre><code data-trim data-noescape class=language-haskell>
							data Show a = Show (a -> String)

							show :: Show a -> a -> String
							show (Show f) a = f a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								showColor :: Show Color
								showColor = Show f
								  where f Red   = "Red"
								        f Green = "Green"
								        f Blue  = "Blue"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								show Red
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								show showColor Red
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="typeclass-eq">
						<h3>Eq Typeclass</h3>
					</section>
					<section id="typeclasses-eq-1">
						Eq Typeclass
						<pre><code data-trim data-noescape class=language-haskell>
							class Eq a where
							  (==) :: a -> a -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Red == Red
								True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Green == Blue
								False
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-eq-2">
						Custom Eq Typeclass instance
						<pre><code data-trim data-noescape class=language-haskell>
							class Eq a where
							  (==) :: a -> a -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Eq Color where
								  (==) Red   Red   = True
								  (==) Green Green = True
								  (==) Blue  Blue  = True
								  (==) _     _     = False
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-eq-3">
						But do all possible implementations make sense?
						<div class="fragment fade-in" style="color: red;">
							NO!
						</div>
					</section>
					<section id="typeclasses-eq-3">
						<div class="fragment fade-in">
							What kind of properties might we expect instances of Eq to have?
						</div>
						<span class="fragment fade-in">
							<span style="color: green;">Reflexivity</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x == x)  ≡  True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<span style="color: green;">Commutativity</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x == y)  ≡  (y == x)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<span style="color: green;">Transitivity</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x == y) &amp;&amp; (y == z)  ≡  (x == z)
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-eq-4">
						<div>What do you think of instances that<br>don't have these properties?</div>
						<span class="fragment fade-in">
							For example:
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> let nan = (0.0 / 0.0) :: Double
								nan :: Double
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> nan == nan
								False
							</code></pre>
						</span>
						<span class="fragment fade-in" style="color: red">
							wat?!
						</span>
					</section>
					<section id="typeclasses-eq-5">
						<div>What could possibly go wrong?</div>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> import Data.Map
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> let nan = (0.0 / 0.0) :: Double
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> let m = fromList [(0.0, "zero"), (nan, "nan")]
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> delete 0.0 m
								fromList [(NaN,"nan")]
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> delete nan m
								fromList [(0.0,"zero"),(NaN,"nan")]
							</code></pre>
						</span>
						<span class="fragment fade-in" style="color: red">
							u wot m8?
						</span>
					</section>
					<section id="typeclasses-eq-6">
						<p>
							"Type classes can’t stand alone. To be useful writing generic
							code, they need to ship with laws that describe how they
							behave."
						</p>
						<p>
							John A De Goes
							<br>
							(Haskell's Type Classes: We Can Do Better)
						</p>
					</section>
				</section>
				<section>
					<section id="typeclass-ord">
						<h3>Ord Typeclass</h3>
					</section>
					<section id="typeclasses-ord-1">
						Ord Typeclass
						<pre><code data-trim data-noescape class=language-haskell>
							data Ordering = LT | EQ | GT deriving (Eq, Show)
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Eq a => Ord a where
								  compare :: a -> a -> Ordering
								<span class="fragment fade-in">
								  x <  y = case compare x y of { LT -> True;  _ -> False }
								  x <= y = case compare x y of { GT -> False; _ -> True  }
								  x >  y = case compare x y of { GT -> True;  _ -> False }
								  x >= y = case compare x y of { LT -> False; _ -> True  }</span>
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue deriving (Eq, Ord, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Red < Green
								True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Green > Blue
								False
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-ord-2">
						<div>
							What laws do you think <code>Ord</code> should have?
						</div>
						<span class="fragment fade-in">
							<span style="color: green;">Transitivity?</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x <= y) &amp;&amp; (y <= z)  ≡  (x <= z)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<span style="color: green;">So maybe not a good idea to give<br>Rock-Paper-Scissors an Ord instance</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(Rock <= Paper) &amp;&amp; (Paper <= Scissors)  ≡  (Rock <= Scissors)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								https://codereview.stackexchange.com/questions/88395/rock-paper-scissors-game
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="vs-oop">
						<h3>How are typeclasses<br>different to OOP?</h3>
					</section>
					<section id="vs-oop-1">
						<p>Function dispatch is based on type, <br>not based on object.
						</p>
						<span class="fragment fade-in">
							<p>
								There is no need to write code<br>to exclude non-sensical cases.
							</p>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-java>
								class Point {
								  public final int x;
								  public final int y;

								  public boolean equals(Object o) {
								    <span style="background: crimson">if (!(o instanceof Point))</span>
								      <span style="background: crimson">return false;</span>
								    <span style="background: crimson">Point p = (Point)o;</span>
								    return (p.x == this.x &amp;&amp; p.y == this.y);
								  }
								}
							</code></pre>
						</span>
					</section>
					<section id="vs-oop-2">
						Data and behaviour are defined separately.
						<span class="fragment fade-in">
							<p>
								It's possible to define new data types<br>for pre-existing behaviours.
							</p>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data TriState = On | Off | Unspecified deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							And define new behaviours for existing datatypes.
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Encode a where
								  encode :: a -> String

								instance Encode Bool where
								  encode True 	= "1"
								  encode False 	= "0"
							</code></pre>
						</span>
					</section>
					<section id="vs-oop-2">
						<code>Data.Map</code> an example of Data/Behaviour separation
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Map k a = Bin k a (Map k a) (Map k a) | Tip
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								empty :: Map k a
								empty = Tip
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								singleton :: k -> a -> Map k a
								singleton k a = Bin k a Tip Tip
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								lookup :: Ord k => k -> Map k a -> Maybe a
								fromList :: Ord k => [(k, a)] -> Map k a
								insert :: Ord k => k -> a -> Map k a -> Map k a
								delete :: Ord k => k -> Map k a -> Map k a
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="overloaded-syntax">
						<h3>Overloaded syntax</h3>
					</section>
					<section id="overloaded-syntax-strings">
						Overloaded syntax for strings
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t "hello" :: String
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								"hello" :: String :: String
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t "hello"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								"hello" :: Data.String.IsString t => t
							</code></pre>
						</span>
					</section>
					<section id="is-string-typeclass">
						IsString Typeclass
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class IsString a where
								  fromString :: String -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance IsString String where
								  fromString s = s
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance IsString [Bool] where
								  fromString ('1':bs) = True :fromString bs
								  fromString ('0':bs) = False:fromString bs
								  fromString (_  :bs) =       fromString bs
								  fromString []       = []
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> "1100 1001" :: [Bool]
								[True,True,False,False,True,False,False,True]
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="semigroup-ord">
						<h3>Semigroup Typeclass</h3>
					</section>
					<section>
						List concatenation
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: String) ++ ("how" :: String)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								"somehow"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: Text) ++ ("how" :: Text)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								error:
								    • Couldn't match expected type ‘[a]’ with actual type ‘Text’
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t (++)
								(++) :: [a] -> [a] -> [a]
							</code></pre>
						</span>
					</section>
					<section id="semigroup-ord-1">
						Semigroup Typeclass
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Semigroup a where
								  (&lt;&gt;) :: a -> a -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							Things that can be smashed together
						</span>
					</section>
					<section>
						Semigroup Concatenation
						<pre><code data-trim data-noescape class=language-haskell>
							class Semigroup a where
							  (&lt;&gt;) :: a -> a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Semigroup [] where
								  (&lt;&gt;) = (++)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: String) &lt;&gt; ("how" :: String)
								"somehow"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Semigroup Text where
								  (&lt;&gt;) = append
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: Text) &lt;&gt; ("how" :: Text)
								"somehow"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t (&lt;&gt;)
								(&lt;&gt;) :: Semigroup a => a -> a -> a
							</code></pre>
						</span>
					</section>
					<section>
						What does smashing together mean anyway?
						<pre><code data-trim data-noescape class=language-haskell>
							class Semigroup a where
							  (&lt;&gt;) :: a -> a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a &lt;&gt; b) &lt;&gt; c  ≡  a &lt;&gt; (b &lt;&gt; c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								("never" ++ "the") ++ "less"  ≡  "nevertheless"
								                              ≡  "never" ++ ("the" ++ "less")
							</code></pre>
						</span>
					</section>
					<section>
						What else?
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a + b) + c   ≡   a + (b + c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a * b) * c   ≡   a * (b * c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a `min` b) `min` c   ≡   a `min` (b `min` c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a `max` b) `max` c   ≡   a `max` (b `max` c)
							</code></pre>
						</span>
					</section>
					<section>
						<div>
							We have four possible semigroups<br>that work on the same type!
						</div>
						<div class="fragment fade-in" style="color: orange">
							But typeclasses dispatch by type.
						</div>
						<div class="fragment fade-in" style="color: red">
							We only have one type, so can
							only dispatch to one implementation.
						</div>
						<div class="fragment fade-in" style="color: lime">
							Don't worry.  Types are cheap.  Just create more.
						</div>
					</section>
					<section>
						Using types to select the correct Semigroup instance
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								newtype Sum a = Sum a deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Num a => Semigroup (Sum a) where
								  (&lt;&gt;) (Sum a) (Sum b) = Sum (a + b)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; Sum 3 &lt;&gt; Sum 4)
								10
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								newtype Max a = Max a deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Ord a => Semigroup (Max a) where
								  (&lt;&gt;) (Max a) (Max b) = Max (a `max` b)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> getMax (Max 1 &lt;&gt; Max 2 &lt;&gt; Max 3 &lt;&gt; Max 4)
								4
							</code></pre>
						</span>
					</section>
					<section>
						But this is awkward
						<pre><code data-trim data-noescape class=language-haskell>
							λ> getMax (Max 1 &lt;&gt; Max 2 &lt;&gt; Max 3 &lt;&gt; Max 4)
							4
						</code></pre>
						<span class="fragment fade-in">
							We can do this instead
							<pre><code data-trim data-noescape class=language-haskell>
								λ> let values = [1, 2, 3, 4] :: [Int]
								λ> getMax (foldMap Max values)
								4
							</code></pre>
						</span>
					</section>
					<section>
						FoldMap function
						<pre><code data-trim data-noescape class=language-haskell>
							λ> :t foldMap
							foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :info []
								data [] a = [] | a : [a]
								...
								instance Foldable [] -- Defined in ‘Data.Foldable’
								...
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :info Max
								newtype Max a = Max {getMax :: a} 	-- Defined in ‘Data.Semigroup’
								...
								instance Ord a => Semigroup (Max a) -- Defined in ‘Data.Semigroup’
								instance (Ord a, Bounded a) => Monoid (Max a)
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="monoid">
						<h3>Monoid typeclass</h3>
					</section>
					<section>
						Monoid definition
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Monoid a where
								  mappend :: a -> a -> a <span class="fragment fade-in"> -- Same as (&lt;&gt;) </span>
								  mempty :: a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							Laws
							<pre><code data-trim data-noescape class=language-haskell>
								a `mappend` (b `mappend` c)  ≡  (a `mappend` b) `mappend` c
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								mempty `mappend` a  ≡  a  ≡  a `mappend` mempty
							</code></pre>
						</span>
					</section>
					<section>
						Monoid instance for Sum
						<pre><code data-trim data-noescape class=language-haskell>
							instance Monoid (Sum a) where
							  mappend = (+)
							  mempty = 0
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								a + (b + c)  ≡  (a + b) + c
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								0 + a  ≡  a  ≡  a + 0
							</code></pre>
						</span>
					</section>
					<section>
						Monoid instance for Product
						<pre><code data-trim data-noescape class=language-haskell>
							instance Monoid (Product a) where
							  mappend = (*)
							  mempty = 1
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								a * (b * c)  ≡  (a * b) * c
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								1 * a  ≡  a  ≡  a * 1
							</code></pre>
						</span>
					</section>
					<section>
						Haskell knows which instance of <code>Monoid</code> to use based
						context in which <code>mempty</code> is used.
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> mempty :: Sum Int
								Sum {getSum = 0}
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> mempty :: Product Int
								Product {getProduct = 1}
							</code></pre>
						</span>
					</section>
					<section>
						Why does <code>foldMap</code> need <code>Monoid</code> rather than
						semigroup?
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> getProduct (foldMap Product [3, 7]) :: Int
								21
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> getProduct (foldMap Product [7]) :: Int
								7
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> getProduct (foldMap Product []) :: Int
								1
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="num-typeclass">
						<h3>Num &amp; Fractional Typeclasses</h3>
					</section>
					<section>
						<h4>Num typeclass</h4>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Num a where
								  (+) :: a -> a -> a
								  (-) :: a -> a -> a
								  (*) :: a -> a -> a
								  negate :: a -> a
								  abs :: a -> a
								  signum :: a -> a
								  fromInteger :: Integer -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> 1 :: Int
								1
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> 1 :: Double
								1.0
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Fractional typeclass</h4>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Num a => Fractional a where
								  (P./) :: a -> a -> a
								  recip :: a -> a
								  fromRational :: Rational -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> 1.3 :: Double
								1.3
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> 1.3 :: Rational
								13 % 10
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="algebraic-expressions">
						<h3>Representing algebraic expressions</h3>
					</section>
					<section>
						<h4>Polynomials</h4>
						<script type="math/tex; mode=display">
							\begin{equation}
								f(x) = 3x^2 + 5x + 1
							\end{equation}
						</script>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								f :: Double -> Double
								f x = 3 * x ** 2 + 5 * x + 1
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								 λ> f 1
								 9.0
							</code></pre>
						</span>
						<span class="fragment fade-in">
							Does one and one thing only.
						</span>
						<span class="fragment fade-in">
							Can we do better?
						</span>
					</section>
					<section>
						<h4>Let's define some typeclasses for algebra</h4>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								import           Prelude hiding ((*), (**), (+), (-), (/))
								import qualified Prelude as P
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								infixr 8  **
								infixl 7  *
								infixl 6  +
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Plus a where
								  (+) :: a -> a -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Multiply a where
								  (*) :: a -> a -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Power a where
								  (**) :: a -> a -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								f x = 3 * x ** 2 + 5 * x + 1
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t f
								f :: (Plus a, Multiply a, Num a, Power a) => a -> a
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Evaluating the polynomial</h4>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Plus Double where
								  (+) u v = u P.+ v
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Multiply Double where
								  (*) u v = u P.* v
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Power Double where
								  (**) u v = u P.** v
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> f 1
								9.0
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Printing the polynomial 1</h4>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data AsciiRep = AsciiRep
								  { ascii      :: String
								  , precedence :: Int
								  } deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Plus AsciiRep where
								  (+) (AsciiRep u p) (AsciiRep v q) =
								    AsciiRep (bracket 6 p u &lt;&gt; " + " &lt;&gt; bracket 6 q v) 6

								instance Multiply AsciiRep where
								  (*) (AsciiRep u p) (AsciiRep v q) =
								    AsciiRep (bracket 7 p u &lt;&gt; " * " &lt;&gt; bracket 7 q v) 7

								instance Power AsciiRep where
								  (**) (AsciiRep u p) (AsciiRep v q) =
								    AsciiRep (bracket 8 p u &lt;&gt; " ** " &lt;&gt; bracket 8 q v) 8
								</code></pre>
							</span>
						</section>
						<section>
							<h4>Printing the polynomial 2</h4>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
									bracket :: Int -> Int -> String -> String
									bracket p q u = if p <= q then u else "(" &lt;&gt; u &lt;&gt; ")"
								</code></pre>
							</span>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
								instance Num AsciiRep where
								  fromInteger n = AsciiRep (show (fromInteger n)) 9
								  (+) _ _   = error "Not implemented"
								  (*) _ _   = error "Not implemented"
								  abs _     = error "Not implemented"
								  signum _  = error "Not implemented"
								  negate _  = error "Not implemented"
								</code></pre>
							</span>
						</section>
						<section>
							<h4>Printing the polynomial 3</h4>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
									asciiRep :: (AsciiRep -> AsciiRep) -> String
									asciiRep f = case f (AsciiRep "x" 9) of
									  AsciiRep s _ -> s
								</code></pre>
							</span>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
									f x = 3 * x ** 2 + 5 * x + 1
								</code></pre>
							</span>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
									λ> asciiRep f
									"3 * x ** 2 + 5 * x + 1"
								</code></pre>
							</span>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
									g x = x * (x + 1)
								</code></pre>
							</span>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
									λ> asciiRep g
									"x * (x + 1)"
								</code></pre>
							</span>
						</section>
						<section>
							<h4>Adding more operations</h4>
							<span class="fragment fade-in">
								<pre><code data-trim data-noescape class=language-haskell>
									class Minus a where
									  (-) :: a -> a -> a

									class Divide a where
									  (/) :: a -> a -> a

									class Power a where
									  (**) :: a -> a -> a
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section>
						<h3>Automatic Differentiation</h3>
					</section>
					<section>
						<h4>Automatic Differentiation</h4>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Dual = Dual
								  { appliedPolynomial :: Double
								  , appliedDerivative :: Double
								  } deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Num Dual where
								  fromInteger n = Dual (fromInteger n) 0
								  ...
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Sum rule</h4>
						<script type="math/tex; mode=display">
							\begin{equation}
								(u + v)^\prime = u^\prime + v^\prime
							\end{equation}
						</script>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Plus Dual where
								  (+) (Dual u u') (Dual v v') = Dual (u + v) (u' + v')
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Difference rule</h4>
						<script type="math/tex; mode=display">
							\begin{equation}
								(u - v)^\prime = u^\prime - v^\prime
							\end{equation}
						</script>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Minus Dual where
								  (-) (Dual u u') (Dual v v') = Dual (u - v) (u' - v')
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Product rule</h4>
						<script type="math/tex; mode=display">
							\begin{equation}
								(uv)^\prime = u^{\prime}v + u v^\prime
							\end{equation}
						</script>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Multiply Dual where
								  (*) (Dual u u') (Dual v v') = Dual (u * v) (u' * v + u * v')
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Quotient rule</h4>
						<script type="math/tex; mode=display">
							\begin{equation}
								\left(\frac{u}{v}\right)^\prime = \frac{u^{\prime}v - u v^\prime}{v^2}
							\end{equation}
						</script>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Divide Dual where
								  (/) (Dual u u') (Dual v v') = Dual (u / v) ((u' v - u * v') / v ^ 2)
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Exponentials - (Chain rule + Product rule)</h4>
						<script type="math/tex; mode=display">
							\begin{equation}
								\begin{split}
									                      y & =          u^v                                                             \\
									                 \ln{y} & =          \ln{u^v}                                                        \\
									                 \ln{y} & =          v\ln{u}                                                         \\
									{\frac{1}{y}}y^{\prime} & =          v^{\prime}\ln{u} + v{\frac{1}{u}}                               \\
									             y^{\prime} & =   y\left(v^{\prime}\ln{u} + v\left({\frac{1}{u}}u^{\prime}\right)\right) \\
															 y^{\prime} & = u^v\left(v^{\prime}\ln{u} + \frac{vu^{\prime}}{u}\right)              \\
								\end{split}
							\end{equation}
						</script>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Power Dual where
								  (**) (Dual u u') (Dual v v') =
								    Dual (u ** v) (u ** v * (v' * log u + (v * u' / u)))
							</code></pre>
						</span>
					</section>
					<section>
						<h4>Applying the derivative</h4>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								derivativeApply :: (Dual -> Dual) -> Double -> Double
								derivativeApply f x = case f (Dual x 1) of
								  Dual _ d -> d
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									f(x) = 3x^2 + 5x + 1
								\end{equation}
							</script>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								f x = 3 * x ** 2 + 5 * x + 1
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									\begin{split}
										f^\prime(x)	& = 6x + 5
									\end{split}
								\end{equation}
							</script>
						</span>
						<span class="fragment fade-in">
							<script type="math/tex; mode=display">
								\begin{equation}
									\begin{split}
										f^\prime(1)	& = 11
									\end{split}
								\end{equation}
							</script>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> derivativeApply f 1
								11.0
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section>
						<h3>Conclusion</h3>
					</section>
					<section>
						<h4>What have we learnt?</h4>
						<ul>
							<li class="fragment fade-in">
									Parametricity and abstraction simplifies
							</li>
							<li class="fragment fade-in">
									Type classes peel back abstractions
							</li>
							<li class="fragment fade-in">
									Laws enable generic re-usable code
							</li>
							<li class="fragment fade-in">
									Type inference can work from context
							</li>
							<li class="fragment fade-in">
									Type wrappers disamguate typeclass instances
							</li>
							<li class="fragment fade-in">
									Typeclasses are highly extensible
							</li>
						</ul>
					</section>
				</section>
				<section>
					<h3>References</h3>
					<ul>
						<li>Haskell's Type Classes: We Can Do Better<br>
								http://degoes.net/articles/principled-typeclasses</li>
						<li>Automatic Differentiation is Trivial in Haskell<br>
						    http://www.danielbrice.net/blog/2015-12-01/</li>
						<li>Typed final (tagless-final) style<br>
						    http://okmij.org/ftp/tagless-final/</li>
						<li>Derivatives of Exponential Functions &amp; Logarithmic Differentiation Calculus<br>
								https://www.youtube.com/watch?v=zmnh448y_ZU
					</ul>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				math: {
					mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
				},
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/math/math.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
