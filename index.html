<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section id="intro">
					Express yourself through Haskell Type-classes
				</section>
				<section id="parametricity">
					<section id="parametricity-1">
						Parametricity
					</section>
					<section id="parametricity-2">
						How many possible implementations of this function?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo = True ; foo = False
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|Bool| = 2
							</code></pre>
						</span>
					</section>
					<section id="parametricity-3">
						How many possible implementations of this function?
						<pre><code data-trim data-noescape class=language-haskell>
							data TriState = On | Off | Unknown
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo = On
								foo = Off
								foo = Unknown
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|TriState| = 3
							</code></pre>
						</span>
					</section>
					<section id="parametricity-4">
						How many possible implementations of this function?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Bool -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo True = True  ; foo False = True
								foo True = False ; foo False = True
								foo True = True  ; foo False = False
								foo True = False ; foo False = False
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|Bool -> Bool| = |Bool| ^ |Bool| = 2 ^ 2 = 4
							</code></pre>
						</span>
					</section>
					<section id="parametricity-5">
						<pre><code data-trim data-noescape class=language-haskell>
							data TriState = On | Off | Unknown
						</code></pre>
						How many possible implementations of this function?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: TriState -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo On = True  ; foo Off = True  ; foo Unkown = True
								foo On = False ; foo Off = True  ; foo Unkown = True
								foo On = True  ; foo Off = False ; foo Unkown = True
								foo On = False ; foo Off = False ; foo Unkown = True
								foo On = True  ; foo Off = True  ; foo Unkown = False
								foo On = False ; foo Off = True  ; foo Unkown = False
								foo On = True  ; foo Off = False ; foo Unkown = False
								foo On = False ; foo Off = False ; foo Unkown = False
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|TriState -> Bool| = |Bool| ^ |TriState| = 2 ^ 3 = 8
							</code></pre>
						</span>
					</section>
					<section id="parametricity-6">
						How many possible implementations of this function?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: A -> B
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|A -> B| = |B| ^ |A|
							</code></pre>
						</span>
					</section>
					<section id="parametricity-7">
						How many possible implementations of this function?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Int -> Int 		-- Int is a 64-bit integer
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|Int -> Int| = <span class="fragment fade-in">(2 ^ 64) ^ (2 ^ 64)</span>
								<span class="fragment fade-in">             = 18446744073709551616 ^ 18446744073709551616</span>
								<span class="fragment fade-in">             > 10 ^ 82</span>
								<span class="fragment fade-in">             ≈ estimated number of atoms in the universe</span>
							</code></pre>
						</span>
					</section>
					<section id="parametricity-7">
						Well, that escalated quickly.
						<img src="assets/escalated.png"/>
					</section>
					<section id="parametricity-7">
						It doesn't get better
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: Int -> String
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|Int -> String|<span class="fragment fade-in"> = |String| ^ |Int|</span>
								<span class="fragment fade-in">                = ∞ ^ 18446744073709551616</span>
							</code></pre>
						</span>
					</section>
					<section id="parametricity-6">
						Are there functions where the possible number of implementations
						don't escalate so much?
					</section>
					<section id="parametricity-6">
						How about this one?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo x = x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|a -> a| = 1
							</code></pre>
						</span>
					</section>
					<section id="parametricity-6">
						Or this one?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: b -> a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo _ x = x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|b -> a -> a| = 1
							</code></pre>
						</span>
					</section>
					<section id="parametricity-6">
						Or this one?
						<pre><code data-trim data-noescape class=language-haskell>
							foo :: (a -> b) -> a -> b
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								foo f x = f x
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								|(a -> b) -> a -> b| = 1
							</code></pre>
						</span>
					</section>
				</section>
				<section id="algebraic-data-types">
					<section>
						Algebraic Data Types
					</section>
					<section id="boolean-1">
						Boolean type
						<pre><code data-trim data-noescape class=language-haskell>
							data Bool = True | False
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :t False
								False :: Bool
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :t True
								True :: Bool
							</code></pre>
						</span>
					</section>
					<section id="boolean-2">
						Boolean type
						<pre><code data-trim data-noescape class=language-haskell>
							data Bool = True | False
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
λ> True
<interactive>:11:1: error:
    • No instance for (Show Bool) arising from a use of ‘print’
      There are instances for similar types:
        instance Show Prelude.Bool -- Defined in ‘GHC.Show’
    • In a stmt of an interactive GHCi command: print it
(0.00 secs,)
							</code></pre>
						</span>
					</section>
					<section id="boolean-3">
						Boolean type
						<pre><code data-trim data-noescape class=language-haskell>
							data Bool = True | False<span class="fragment fade-in"> deriving Show</span>
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> True
								True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> show True
								"True"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :t show
								show :: Show a => a -> String
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=no-highlight>
								λ> :info Show
								class Show a where
								  show :: a -> String
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="typeclass-show">
						Show Typeclass
					</section>
					<section id="typeclasses-show-1">
						Show Typeclass
						<pre><code data-trim data-noescape class=language-haskell>
							class Show a where
							  (==) :: a -> String
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Show Color where
								  show Red   = "Red"
								  show Green = "Green"
								  show Blue  = "Blue"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								deriving instance Show Color
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue deriving Show
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="typeclass-eq">
						Eq Typeclass
					</section>
					<section id="typeclasses-eq-1">
						Eq Typeclass
						<pre><code data-trim data-noescape class=language-haskell>
							class Eq a where
							  (==) :: a -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Red == Red
								True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Green == Blue
								False
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-eq-2">
						Custom Eq Typeclass instance
						<pre><code data-trim data-noescape class=language-haskell>
							class Eq a where
							  (==) :: a -> a -> Bool
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Eq Color where
								  (==) Red   Red   = True
								  (==) Green Green = True
								  (==) Blue  Blue  = True
								  (==) _     _     = False
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-eq-3">
						But do all possible implementations make sense?
						<div class="fragment fade-in" style="color: red;">
							NO!
						</div>
					</section>
					<section id="typeclasses-eq-3">
						<div class="fragment fade-in">
							What kind of properties might we expect instances of Eq to have?
						</div>
						<span class="fragment fade-in">
							<span style="color: green;">Reflexivity</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x == x)  ≡  True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<span style="color: green;">Commutativity</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x == y)  ≡  (y == x)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<span style="color: green;">Transitivity</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x == y) &amp;&amp; (y == z)  ≡  (x == z)
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-eq-4">
						<div>What do you think of instances that<br>don't have these properties?</div>
						<span class="fragment fade-in">
							For example:
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> let nan = (0.0 / 0.0) :: Double
								nan :: Double
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> nan == nan
								False
							</code></pre>
						</span>
						<span class="fragment fade-in" style="color: red">
							wat?!
						</span>
					</section>
					<section id="typeclasses-eq-5">
						<div>What could possibly go wrong?</div>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> import Data.Map
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> let nan = (0.0 / 0.0) :: Double
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> let m = fromList [(0.0, "zero"), (nan, "nan")]
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> delete 0.0 m
								fromList [(NaN,"nan")]
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> delete nan m
								fromList [(0.0,"zero"),(NaN,"nan")]
							</code></pre>
						</span>
						<span class="fragment fade-in" style="color: red">
							u wot m8?
						</span>
					</section>
					<section id="typeclasses-eq-6">
						<p>
							"Type classes can’t stand alone. To be useful writing generic
							code, they need to ship with laws that describe how they
							behave."
						</p>
						<p>
							John A De Goes
							<br>
							(Haskell's Type Classes: We Can Do Better)
						</p>
					</section>
				</section>
				<section>
					<section id="typeclass-ord">
						Ord Typeclass
					</section>
					<section id="typeclasses-ord-1">
						Ord Typeclass
						<pre><code data-trim data-noescape class=language-haskell>
							data Ordering = LT | EQ | GT deriving (Eq, Show)
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Eq a => Ord a where
								  compare :: a -> a -> Bool
								<span class="fragment fade-in">
								  x <  y = case compare x y of { LT -> True;  _ -> False }
								  x <= y = case compare x y of { GT -> False; _ -> True  }
								  x >  y = case compare x y of { GT -> True;  _ -> False }
								  x >= y = case compare x y of { LT -> False; _ -> True  }</span>
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Color = Red | Green | Blue deriving (Eq, Ord, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Red < Green
								True
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> Green > Blue
								False
							</code></pre>
						</span>
					</section>
					<section id="typeclasses-ord-2">
						<div>
							What laws do you think <code>Ord</code> should have?
						</div>
						<span class="fragment fade-in">
							<span style="color: green;">Transitivity?</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(x <= y) &amp;&amp; (y <= z)  ≡  (x <= z)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<span style="color: green;">So maybe not a good idea to give<br>Rock-Paper-Scissors an Ord instance</span>
							<pre><code data-trim data-noescape class=language-haskell>
								(Rock <= Paper) &amp;&amp; (Paper <= Scissors)  ≡  (Rock <= Scissors)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								https://codereview.stackexchange.com/questions/88395/rock-paper-scissors-game
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="vs-oop">
						How are typeclasses different to OOP?
					</section>
					<section id="vs-oop-1">
						<p>Function dispatch is based on type, <br>not based on object.
						</p>
						<span class="fragment fade-in">
							<p>
								There is no need to write code<br>to exclude non-sensical cases.
							</p>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-java>
								class Point {
								  public final int x;
								  public final int y;

								  public boolean equals(Object o) {
								    <span style="background: crimson">if (!(o instanceof Point))</span>
								      <span style="background: crimson">return false;</span>
								    <span style="background: crimson">Point p = (Point)o;</span>
								    return (p.x == this.x &amp;&amp; p.y == this.y);
								  }
								}
							</code></pre>
						</span>
					</section>
					<section id="vs-oop-2">
						Data and behaviour are defined separately.
						<span class="fragment fade-in">
							<p>
								It's possible to define new data types<br>for pre-existing behaviours.
							</p>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data TriState = On | Off | Unspecified deriving (Eq, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							And define new behaviours for existing datatypes.
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Encode a where
								  encode :: a -> String

								instance Encode Bool where
								  encode True 	= "1"
								  encode False 	= "0"
							</code></pre>
						</span>
					</section>
					<section id="vs-oop-2">
						<code>Data.Map</code> an example of Data/Behaviour separation
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								data Map k a = Bin (Map k a) a (Map k a) | Tip
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								empty :: Map k a
								empty = Tip
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								singleton :: Map k a
								singleton a = Bin Tip a Tip
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								lookup :: Ord k => k -> Map k a -> Maybe a
								fromList :: Ord k => [(k, a)] -> Map k a
								insert :: Ord k => k -> a -> Map k a -> Map k a
								delete :: Ord k => k -> Map k a -> Map k a
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="overloaded-syntax">
						Overloaded syntax
					</section>
					<section id="overloaded-syntax-strings">
						Overloaded syntax for strings
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t "hello" :: String
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								"hello" :: String :: String
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t "hello"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								"hello" :: Data.String.IsString t => t
							</code></pre>
						</span>
					</section>
					<section id="is-string-typeclass">
						IsString Typeclass
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class IsString a where
								  fromString :: String -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance IsString String where
								  fromString s = s
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance IsString [Bool] where
								  fromString ('1':bs) = True :fromString bs
								  fromString ('0':bs) = False:fromString bs
								  fromString (_  :bs) =       fromString bs
								  fromString []       = []
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> "1100 1001" :: [Bool]
								[True,True,False,False,True,False,False,True]
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<section id="semigroup-ord">
						Semigroup Typeclass
					</section>
					<section>
						List concatenation
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: String) ++ ("how" :: String)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								"somehow"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: Text) ++ ("how" :: Text)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								error:
								    • Couldn't match expected type ‘[a]’ with actual type ‘Text’
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t (++)
								(++) :: [a] -> [a] -> [a]
							</code></pre>
						</span>
					</section>
					<section id="semigroup-ord-1">
						Semigroup Typeclass
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								class Semigroup a where
								  (&lt;&gt;) :: a -> a -> a
							</code></pre>
						</span>
						<span class="fragment fade-in">
							Things that can be smashed together
						</span>
					</section>
					<section>
						Semigroup Concatenation
						<pre><code data-trim data-noescape class=language-haskell>
							class Semigroup a where
							  (&lt;&gt;) :: a -> a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Semigroup [] where
								  (&lt;&gt;) = (++)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: String) &lt;&gt; ("how" :: String)
								"somehow"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Semigroup Text where
								  (&lt;&gt;) = append
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> ("some" :: Text) &lt;&gt; ("how" :: Text)
								"somehow"
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> :t (&lt;&gt;)
								(&lt;&gt;) :: Semigroup a => a -> a -> a
							</code></pre>
						</span>
					</section>
					<section>
						What does smashing together mean anyway?
						<pre><code data-trim data-noescape class=language-haskell>
							class Semigroup a where
							  (&lt;&gt;) :: a -> a -> a
						</code></pre>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a &lt;&gt; b) &lt;&gt; c  ≡  a &lt;&gt; (b &lt;&gt; c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								("never" ++ "the") ++ "less"  ≡  "nevertheless"
								                              ≡  "never" ++ ("the" ++ "less")
							</code></pre>
						</span>
					</section>
					<section>
						What else?
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a + b) + c   ≡   a + (b + c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a * b) * c   ≡   a * (b * c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a `min` b) `min` c   ≡   a `min` (b `min` c)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								(a `max` b) `max` c   ≡   a `max` (b `max` c)
							</code></pre>
						</span>
					</section>
					<section>
						<div>
							We have four possible semigroups<br>that work on the same type!
						</div>
						<div class="fragment fade-in" style="color: orange">
							But typeclasses dispatch by type.
						</div>
						<div class="fragment fade-in" style="color: red">
							We only have one type, so can
							only dispatch to one implementation.
						</div>
						<div class="fragment fade-in" style="color: lime">
							Don't worry.  Types are cheap.  Just create more.
						</div>
					</section>
					<section>
						Using types to select the correct Semigroup instance
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								newtype Sum a = Sum a deriving (Eq, Ord, Num, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Semigroup (Sum a) where
								  (&lt;&gt;) (Sum a) (Sum b) = Sum (a + b)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; Sum 3 &lt;&gt; Sum 4)
								10
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								newtype Max a = Max a deriving (Eq, Ord, Num, Show)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								instance Semigroup (Max a) where
								  (&lt;&gt;) (Max a) (Max b) = Max (a `max` b)
							</code></pre>
						</span>
						<span class="fragment fade-in">
							<pre><code data-trim data-noescape class=language-haskell>
								λ> getMax (Max 1 &lt;&gt; Max 2 &lt;&gt; Max 3 &lt;&gt; Max 4)
								4
							</code></pre>
						</span>
					</section>
				</section>
				<section>
					<h3>References</h3>
					<ul>
						<li>Haskell's Type Classes: We Can Do Better<br>
								http://degoes.net/articles/principled-typeclasses</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
